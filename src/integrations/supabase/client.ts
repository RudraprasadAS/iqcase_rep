
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://nytxdkvpgbvndtbvcvxz.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im55dHhka3ZwZ2J2bmR0YnZjdnh6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDczNjk0MDQsImV4cCI6MjA2Mjk0NTQwNH0.TpmAezgRrXiLaXFLVC98wPkY3hpV8y0Ogc_EatasxTQ";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create custom fetch function with logging
const createLoggingFetch = (originalFetch: typeof window.fetch) => {
  return function(input: RequestInfo | URL, init?: RequestInit) {
    // Only log Supabase API calls
    if (typeof input === 'string' && input.includes('supabase')) {
      const isRolePermissionRequest = typeof input === 'string' && input.includes('/permissions');
      
      // Parse body safely based on content type
      let parsedBody: any = undefined;
      if (init?.body) {
        try {
          if (typeof init.body === 'string') {
            parsedBody = JSON.parse(init.body);
          } else if (init.body instanceof FormData) {
            parsedBody = '[FormData]';
          } else if (init.body instanceof Blob) {
            parsedBody = '[Blob]';
          } else if (init.body instanceof ArrayBuffer) {
            parsedBody = '[ArrayBuffer]';
          } else {
            parsedBody = '[Unknown Body Type]';
          }
        } catch (error) {
          parsedBody = '[Unparseable Body]';
        }
      }
      
      console.log('[Supabase Fetch]', {
        url: input,
        method: init?.method,
        headers: init?.headers,
        body: parsedBody
      });
      
      // For permissions requests, add more detailed logging
      if (isRolePermissionRequest) {
        console.log('[Permission Request Details]', {
          url: input,
          method: init?.method,
          body: parsedBody
        });
      }
      
      // Return the original fetch with timing
      const startTime = performance.now();
      return originalFetch.apply(this, [input, init])
        .then(response => {
          const duration = performance.now() - startTime;
          
          // Clone the response to read its body without consuming it
          const clonedResponse = response.clone();
          
          if (isRolePermissionRequest) {
            clonedResponse.json().then(data => {
              console.log(`[Permission Response] Status: ${response.status}, Data:`, data);
            }).catch(err => {
              console.log(`[Permission Response] Could not parse body: ${err}`);
            });
          }
          
          console.log(`[Supabase Response] Status: ${response.status}, Time: ${duration.toFixed(2)}ms`);
          return response;
        })
        .catch(error => {
          console.error('[Supabase Error]', error);
          throw error;
        });
    }
    
    // For non-Supabase calls, just use the original fetch
    return originalFetch.apply(this, [input, init]);
  };
};

// Ensure fetch is available
const fetchImpl = typeof window !== 'undefined' ? createLoggingFetch(window.fetch) : fetch;
if (typeof window !== 'undefined') {
  window.fetch = fetchImpl;
}

// Create and export the Supabase client
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    global: {
      fetch: fetchImpl as typeof fetch
    },
    db: {
      schema: 'public'
    }
  }
);

// Helper function for permission operations
export const permissionsApi = {
  // Delete duplicate permissions for a role
  async cleanupDuplicatePermissions(roleId: string): Promise<void> {
    console.log(`[permissionsApi] Cleaning up duplicate permissions for role: ${roleId}`);
    try {
      // First, get all permissions for the role
      const { data: permissions, error: fetchError } = await supabase
        .from("permissions")
        .select("*")
        .eq("role_id", roleId);
        
      if (fetchError) {
        console.error("[permissionsApi] Error fetching permissions:", fetchError);
        return;
      }
      
      // Group permissions by module_name and field_name
      const groupedPermissions = permissions?.reduce((acc: Record<string, any[]>, perm) => {
        const key = `${perm.module_name}|${perm.field_name || 'null'}`;
        if (!acc[key]) acc[key] = [];
        acc[key].push(perm);
        return acc;
      }, {});
      
      // For each group that has more than 1 permission, keep only the most recent one
      for (const [key, perms] of Object.entries(groupedPermissions || {})) {
        if (perms.length > 1) {
          // Sort by created_at descending (newest first)
          perms.sort((a, b) => 
            new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
          );
          
          // Keep the newest, delete the rest
          const [newest, ...duplicates] = perms;
          console.log(`[permissionsApi] Found ${duplicates.length} duplicates for ${key}. Keeping ID: ${newest.id}`);
          
          if (duplicates.length > 0) {
            const idsToDelete = duplicates.map(d => d.id);
            const { error: deleteError } = await supabase
              .from("permissions")
              .delete()
              .in("id", idsToDelete);
              
            if (deleteError) {
              console.error("[permissionsApi] Error deleting duplicate permissions:", deleteError);
            } else {
              console.log(`[permissionsApi] Successfully deleted ${idsToDelete.length} duplicate permissions`);
            }
          }
        }
      }
    } catch (e) {
      console.error("[permissionsApi] Exception in cleanupDuplicatePermissions:", e);
    }
  }
};
